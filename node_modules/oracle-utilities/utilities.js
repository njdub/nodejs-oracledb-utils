"use strict";
//Oracle

var identifierRegexp = /^[0-9,a-z,A-Z_\.]*$/;
var quoteIdentifierRegexp = /^\'[0-9,a-z,A-Z_\.]*\'$/;

var escapeIdentifier = function (str, quote) {
    quote = quote || "\"";
    if (identifierRegexp.test(str)) return str;
    else return quote + str + quote;
};

var quoteEscapeIdentifier = function (str, quote) {
    quote = quote || "\'";
    if (quoteIdentifierRegexp.test(str)) {
        return str;
    }
    else {
        return quote + str + quote;
    }
};

var prepareValue = function (value) {
    return (typeof(value) === 'number' ? value : quoteEscapeIdentifier(value))
};

var prepareTable = function (table) {
    var dotIndex = table.lastIndexOf('.');
    if (dotIndex !== -1) {
        table = table.substr(dotIndex + 1, table.length);
    }
    return table;
};

var startsWith = function (value, str) {
    return value.slice(0, str.length) == str;
};

function clearQuery(connection, sql, values, callBack) {
    return connection.execute(sql, values, function (err, result) {
        if (callBack) {
            callBack(err, result);
        }
    });
}

module.exports = {

    upgrade: function (connection) {

        //Complete
        connection.query = function (sql, values, callback) {
            if (typeof(values) == 'function') {
                callback = values;
                values = [];
            }
            return clearQuery(this, sql, values, function (err, res, fields) {
                if (callback) {
                    callback(err, res, fields);
                }
            });
        };

        //Complete (need revision)
        connection.where = function (where) {
            var dbc = this,
                result = '';
            for (var key in where) {
                var value = where[key],
                    clause = key;
                if (typeof(value) === 'number') clause = key + ' = ' + value;
                else if (typeof(value) === 'string') {
                    if (startsWith(value, '>=')) clause = key + ' >= ' + quoteEscapeIdentifier(value.substring(2));
                    else if (startsWith(value, '<=')) clause = key + ' <= ' + quoteEscapeIdentifier(value.substring(2));
                    else if (startsWith(value, '<>')) clause = key + ' <> ' + quoteEscapeIdentifier(value.substring(2));
                    else if (startsWith(value, '>')) clause = key + ' > ' + quoteEscapeIdentifier(value.substring(1));
                    else if (startsWith(value, '<')) clause = key + ' < ' + quoteEscapeIdentifier(value.substring(1));
                    else if (startsWith(value, '(')) clause = key + ' IN (' + value.substr(1, value.length - 2).split(',').map(function (s) {
                            return quoteEscapeIdentifier(s);
                        }).join(',') + ')';
                    else if (value.indexOf('..') !== -1) {
                        value = value.split('..');
                        clause = '(' + key + ' BETWEEN ' + quoteEscapeIdentifier(value[0]) + ' AND ' + quoteEscapeIdentifier(value[1]) + ')';
                    } else if ((value.indexOf('*') !== -1) || (value.indexOf('?') !== -1)) {
                        value = value.replace(/\*/g, '%').replace(/\?/g, '_');
                        clause = key + ' LIKE ' + quoteEscapeIdentifier(value);
                    } else clause = key + ' = ' + quoteEscapeIdentifier(value);
                }
                if (result) result = result + ' AND ' + clause; else result = clause;
            }
            return result;
        };

        //Complete (need revision)
        connection.order = function (order) {
            var result = [];
            for (var key in order) {
                var val = order[key],
                    clause = key;
                result.push(clause + ' ' + val);
            }
            if (result.length) {
                return result.join();
            } else {
                return '';
            }
        };

        //Complete
        connection.count = function (table, where, callback) {
            if (typeof(where) == 'function') {
                callback = where;
                where = undefined;
            }
            where = this.where(where);
            var sql = 'SELECT COUNT(*) FROM ' + escapeIdentifier(table);
            if (where) {
                sql = sql + ' WHERE ' + where;
            }
            console.log(sql);
            return this.queryValue(sql, [], function (err, res) {
                callback(err, res);
            });
        };

        //Complete
        connection.queryRow = function (sql, values, callback) {
            if (typeof(values) == 'function') {
                callback = values;
                values = [];
            }
            return clearQuery(this, sql, values, function (err, res, fields) {
                var result;
                if (err) {
                    result = false;
                } else {
                    if (res.rows[0]) {
                        result = {};
                        for (var key in res.rows[0]) {
                            result[res.metaData[key].name] = res.rows[0][key];
                        }
                        res = res.rows[0];
                    } else {
                        result = false;
                    }
                }
                callback(err, result, fields);
            });
        };

        //Complete
        connection.queryValue = function (sql, values, callback) {
            if (typeof(values) == 'function') {
                callback = values;
                values = [];
            }
            return clearQuery(this, sql, values, function (err, res, fields) {
                if (err) {
                    res = false;
                } else {
                    if (res.rows[0]) {
                        res = res.rows[0][0]
                    } else {
                        res = false;
                    }
                }
                callback(err, res, fields);
            });
        };

        //Complete
        connection.queryCol = function (sql, values, callback) {
            if (typeof(values) == 'function') {
                callback = values;
                values = [];
            }
            return clearQuery(this, sql, values, function (err, res, fields) {
                var result = [];
                if (err) {
                    result = false;
                } else {
                    if (res.rows[0]) {
                        for (var i in res.rows) {
                            var row = res.rows[i];
                            result.push(row[Object.keys(row)[0]]); //row[i][0]
                        }
                    } else {
                        result = false;
                    }
                }
                callback(err, result, fields);
            });
        };

        //Complete
        connection.queryHash = function (sql, values, callback) {
            if (typeof(values) == 'function') {
                callback = values;
                values = [];
            }
            return clearQuery(this, sql, values, function (err, res, fields) {
                var result = {};
                if (err) {
                    result = false;
                } else {
                    for (var i in res.rows) {
                        var row = res.rows[i];
                        result[row[0]] = {};
                        for (var column in row) {
                            result[row[0]][res.metaData[column].name] = row[column];
                        }
                    }
                }
                callback(err, result, fields);
            });
        };

        //Complete
        connection.queryKeyValue = function (sql, values, callback) {
            if (typeof(values) == 'function') {
                callback = values;
                values = [];
            }
            return clearQuery(this, sql, values, function (err, res, fields) {
                var result = {};
                if (err) {
                    result = false;
                } else {
                    for (var i in res.rows) {
                        result[res.rows[i][0]] = res.rows[i][1];
                    }
                }
                callback(err, result, fields);
            });
        };

        //Complete (need revision)
        connection.select = function (table, fields, where, order, callback) {
            where = this.where(where);
            if (typeof(order) == 'function') {
                callback = order;
                order = {};
            }
            order = this.order(order);
            var sql = 'SELECT ' + fields + ' FROM ' + escapeIdentifier(table);
            if (where) sql = sql + ' WHERE ' + where;
            if (order) sql = sql + ' ORDER BY ' + order;
            console.log(sql);
            var query = clearQuery(this, sql, [], function (err, res) {
                callback(err, res.rows, query);
            });
        };

        //Complete (need revision)
        connection.insert = function (table, row, callback) {
            var dbc = this;
            dbc.fields(table, function (err, fields) {
                if (!err) {
                    fields = Object.keys(fields);
                    var rowKeys = Object.keys(row),
                        values = [],
                        columns = [];
                    for (var i in fields) {
                        var field = fields[i];
                        if (rowKeys.indexOf(field) != -1) {
                            columns.push(field);
                            values.push(typeof(row[field]) === 'number' ? row[field] : quoteEscapeIdentifier(row[field]));
                        }
                    }
                    values = values.join(', ');
                    columns = columns.join(', ');
                    var command = 'INSERT INTO ' + escapeIdentifier(table) + ' (' + columns + ') VALUES (' + values + ')';
                    console.log(command);
                    var query = dbc.query('INSERT INTO ' + escapeIdentifier(table) + ' (' + columns + ') VALUES (' + values + ')', [], function (err, res) {
                        callback(err, res ? true : false, query);
                        //TODO: Here we have deference between MySLQ-Utilities, don't return insertID
                        //callback(err, res ? res.insertId : false, query);
                    });
                } else callback(new Error('Error: Table "' + table + '" not found'), false);
            });
        };

        //Complete
        connection.update = function (table, row, where, callback) {
            var dbc = this;
            if (typeof(where) == 'function') {
                callback = where;
                dbc.fields(table, function (err, fields) {
                    if (!err) {
                        var where = '',
                            data = [],
                            rowKeys = Object.keys(row);
                        for (var i in fields) {
                            var field = fields[i],
                                fieldName = field['COLUMN_NAME'];
                            if (rowKeys.indexOf(fieldName) != -1) {
                                if (!where && (field['CONSTRAINT_TYPE'] == 'P' || field['CONSTRAINT_TYPE'] == 'U')) where = fieldName + '=' + prepareValue(row[fieldName]);
                                else data.push(fieldName + '=' + prepareValue(row[fieldName]));
                            }
                        }
                        if (where) {
                            data = data.join(', ');
                            //var command = 'UPDATE ' + escapeIdentifier(table) + ' SET ' + data + ' WHERE ' + where;
                            //console.log(command);
                            var query = dbc.query('UPDATE ' + escapeIdentifier(table) + ' SET ' + data + ' WHERE ' + where, [], function (err, res) {
                                callback(err, res ? res.rowsAffected : false, query);
                            });
                        } else {
                            var e = new Error('Error: can not insert into "' + table + '" because there is no primary or unique key specified');
                            //dbc.emit('error', e); TODO:
                            callback(e, false);
                        }
                    } else callback(new Error('Error: Table "' + table + '" not found'), false);
                });
            } else {
                where = this.where(where);
                if (where) {
                    var data = [];
                    for (var i in row) data.push(i + '=' + prepareValue(row[i]));
                    data = data.join(', ');
                    var query = dbc.query('UPDATE ' + escapeIdentifier(table) + ' SET ' + data + ' WHERE ' + where, [], function (err, res) {
                        callback(err, res ? res.rowsAffected : false, query);
                    });
                } else {
                    var e = new Error('Error: can update "' + table + '", because "where" parameter is empty');
                    //dbc.emit('error', e); TODO:
                    callback(e, false);
                }
            }
        };

        //Complete
        connection.upsert = function (table, row, callback) {
            var dbc = this;
            dbc.fields(table, function (err, fields) {
                if (!err) {
                    var rowKeys = Object.keys(row),
                        uniqueKey = '';
                    for (var i in fields) {
                        var field = fields[i],
                            fieldName = field['COLUMN_NAME'];
                        if (!uniqueKey && (field['CONSTRAINT_TYPE'] == 'P' || field['CONSTRAINT_TYPE'] == 'U') && rowKeys.indexOf(fieldName) != -1) uniqueKey = fieldName;
                    }
                    if (rowKeys.indexOf(uniqueKey) != -1) {
                        dbc.queryValue('SELECT count(*) FROM ' + escapeIdentifier(table) + ' WHERE ' + uniqueKey + '=' + prepareValue(row[uniqueKey]), [], function (err, count) {
                            if (count == 1) dbc.update(table, row, callback);
                            else dbc.insert(table, row, callback);
                        });
                    } else {
                        var e = new Error('Error: can not insert or update table "' + table + '", primary or unique key is not specified');
                        //dbc.emit('error', e); TODO:
                        callback(e, false);
                    }
                } else callback(new Error('Error: Table "' + table + '" not found'), false);
            });
        };

        //Complete
        connection.delete = function (table, where, callback) {
            var dbc = this;
            where = this.where(where);
            if (where) {
                var query = dbc.query('DELETE FROM ' + escapeIdentifier(table) + ' WHERE ' + where, [], function (err, res) {
                    callback(err, res ? res.rowsAffected : false);
                });
            } else {
                var e = new Error('Error: can not delete from "' + table + '", because "where" parameter is empty');
                dbc.emit('error', e);
                callback(e, false);
            }
        };
    },

    introspection: function (connection) {

        //Complete
        connection.primary = function (table, callback) {
            table = prepareTable(table);
            var sql = 'SELECT c.CONSTRAINT_NAME, a.COLUMN_NAME, a.OWNER, a.TABLE_NAME, a.DATA_TYPE, a.DATA_LENGTH, a.NULLABLE, c.CONSTRAINT_TYPE, c.STATUS ' +
                'FROM ALL_TAB_COLUMNS a ' +
                'INNER JOIN ALL_CONS_COLUMNS b ' +
                'ON a.OWNER = b.OWNER  AND a.TABLE_NAME = b.TABLE_NAME AND a.COLUMN_NAME = b.COLUMN_NAME ' +
                'INNER JOIN ALL_CONSTRAINTS c ' +
                'ON b.OWNER = c.OWNER  AND b.TABLE_NAME = c.TABLE_NAME AND b.CONSTRAINT_NAME = c.CONSTRAINT_NAME ' +
                'WHERE c.CONSTRAINT_TYPE = \'P\' AND a.TABLE_NAME = ' + quoteEscapeIdentifier(table);
            this.queryHash(sql, [], function (err, res) {
                if (err) {
                    res = false;
                }
                callback(err, res);
            });
        };

        //Complete
        connection.foreign = function (table, callback) {
            table = prepareTable(table);
            var sql = 'SELECT c.CONSTRAINT_NAME, a.COLUMN_NAME, a.OWNER, a.TABLE_NAME, a.DATA_TYPE, a.DATA_LENGTH, a.NULLABLE, c.CONSTRAINT_TYPE, c.STATUS ' +
                'FROM ALL_TAB_COLUMNS a ' +
                'INNER JOIN ALL_CONS_COLUMNS b ' +
                'ON a.OWNER = b.OWNER  AND a.TABLE_NAME = b.TABLE_NAME AND a.COLUMN_NAME = b.COLUMN_NAME ' +
                'INNER JOIN ALL_CONSTRAINTS c ' +
                'ON b.OWNER = c.OWNER  AND b.TABLE_NAME = c.TABLE_NAME AND b.CONSTRAINT_NAME = c.CONSTRAINT_NAME ' +
                'WHERE c.CONSTRAINT_TYPE = \'R\' AND a.TABLE_NAME = ' + quoteEscapeIdentifier(table);
            this.queryHash(sql, [], function (err, res) {
                if (err) {
                    res = false;
                }
                callback(err, res);
            });
        };

        //Complete
        connection.constraints = function (table, callback) {
            table = prepareTable(table);
            var sql = 'SELECT c.CONSTRAINT_NAME, a.COLUMN_NAME, a.OWNER, a.TABLE_NAME, a.DATA_TYPE, a.DATA_LENGTH, a.NULLABLE, c.CONSTRAINT_TYPE, c.STATUS ' +
                'FROM ALL_TAB_COLUMNS a ' +
                'INNER JOIN ALL_CONS_COLUMNS b ' +
                'ON a.OWNER = b.OWNER  AND a.TABLE_NAME = b.TABLE_NAME AND a.COLUMN_NAME = b.COLUMN_NAME ' +
                'INNER JOIN ALL_CONSTRAINTS c ' +
                'ON b.OWNER = c.OWNER  AND b.TABLE_NAME = c.TABLE_NAME AND b.CONSTRAINT_NAME = c.CONSTRAINT_NAME ' +
                'WHERE c.CONSTRAINT_TYPE != \'C\' AND a.TABLE_NAME = ' + quoteEscapeIdentifier(table);
            this.queryHash(sql, [], function (err, res) {
                if (err) {
                    res = false;
                }
                callback(err, res);
            });
        };

        //Complete
        connection.fields = function (table, callback) {
            table = prepareTable(table);
            this.queryHash(
                'SELECT a.COLUMN_NAME, a.OWNER, a.TABLE_NAME, a.DATA_TYPE, a.DATA_LENGTH, a.NULLABLE, c.CONSTRAINT_NAME, c.CONSTRAINT_TYPE, c.STATUS ' +
                'FROM ALL_TAB_COLUMNS a ' +
                'LEFT JOIN ALL_CONS_COLUMNS b ' +
                'ON a.OWNER = b.OWNER  AND a.TABLE_NAME = b.TABLE_NAME AND a.COLUMN_NAME = b.COLUMN_NAME ' +
                'LEFT JOIN ALL_CONSTRAINTS c ' +
                'ON b.OWNER = c.OWNER  AND b.TABLE_NAME = c.TABLE_NAME AND b.CONSTRAINT_NAME = c.CONSTRAINT_NAME ' +
                'WHERE (c.CONSTRAINT_TYPE <> \'C\' OR c.CONSTRAINT_TYPE  IS NULL)  AND a.TABLE_NAME = '
                + quoteEscapeIdentifier(table), [], function (err, res) {
                    if (err) {
                        res = false;
                    }
                    callback(err, res);
                });
        };

        //Only for DBA
        //Complete
        connection.databases = function (callback) {
            this.queryCol('SELECT USERNAME FROM DBA_USERS', [], function (err, res) {
                if (err) res = false;
                callback(err, res);
            });
        };

        //Complete
        connection.tables = function (callback) {
            var sql = 'SELECT * FROM USER_OBJECTS WHERE OBJECT_TYPE = \'TABLE\'';
            this.queryHash(sql, [], function (err, res) {
                if (err) {
                    res = false;
                }
                callback(err, res);
            });
        };

        //Only for DBA
        //Complete
        connection.databaseTables = function (database, callback) {
            var sql =
                'SELECT ' +
                'OBJECT_NAME, SUBOBJECT_NAME, OBJECT_ID, DATA_OBJECT_ID,CREATED,LAST_DDL_TIME,TIMESTAMP,STATUS,TEMPORARY, ' +
                'GENERATED, SECONDARY, NAMESPACE, EDITION_NAME ' +
                'FROM DBA_OBJECTS WHERE OBJECT_TYPE = \'TABLE\' AND OWNER = ' + quoteEscapeIdentifier(database);
            this.queryHash(sql, [], function (err, res) {
                if (err) {
                    res = false;
                }
                callback(err, res);
            });
        };

        //Complete
        connection.tableInfo = function (table, callback) {
            table = prepareTable(table);
            var sql = 'select * FROM USER_OBJECTS WHERE OBJECT_TYPE = \'TABLE\' AND OBJECT_NAME = ' + quoteEscapeIdentifier(table);
            this.queryRow(sql, [], function (err, res) {
                if (err) {
                    res = false;
                }
                callback(err, res);
            });
        };

        //Complete
        connection.indexes = function (table, callback) {
            table = prepareTable(table);
            var sql =
                'SELECT * FROM USER_INDEXES WHERE TABLE_NAME = ' + quoteEscapeIdentifier(table);
            this.queryHash(sql, [], function (err, res) {
                if (err) {
                    res = false;
                }
                callback(err, res);
            });
        };

        //Only for DBA
        //Complete
        connection.processes = function (callback) {
            this.queryHash('SELECT sess.process, sess.status, sess.username, sess.schemaname, sql.sql_text FROM v$session sess, v$sql sql WHERE sql.sql_id(+) = sess.sql_id AND sess.type = \'USER\'', [], function (err, res) {
                if (err) res = false;
                callback(err, res);
            });
        };


        //Now only for DBA
        //DBA_USERS describes all users of the database, and contains more columns than ALL_USERS.
        //USER_USERS describes the current user, and contains more columns than ALL_USERS.
        connection.users = function (callback) {
            this.queryHash('SELECT * FROM DBA_USERS', [], function (err, res) {
                if (err) res = false;
                callback(err, res);
            });
        };
    }

};
